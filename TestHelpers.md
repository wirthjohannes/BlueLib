# TestHelpers

This package contains same useful utitlities for testbenches.

## Scoreboard

This is a small helper module to compare to sets of data sequences (typically a reference one and one generated by the DUT).
You just need to feed it with the respective data and it will automatically compare it and print error messages in the case of a mismatch.
This will also work for complex data like `structs` etc.

Interface:
```
interface Scoreboard#(type a);
    interface Put#(a) reference;
    interface Put#(a) dut;
    method Action checkFinished();
    method UInt#(64) matchedCount();
endinterface
```

Usage:
```
// The first parameter is the custom name and used for printing via the Logging library (should not contain whitespaces)
// The second parameter is the internal FIFO size. This only needs to hold the currently "open" items, but not the ones which were already compared.
// So it just needs to be big enough to hold the "maximum imbalance" between reference and dut sequences.
// The module will print a warning when a FIFO runs full.
Scoreboard#(Bit#(32)) scoreboard <- mkScoreboardInorder("MyScoreboard", 16);
Stms s = {
    seq
    // Feed reference and DUT values
    scoreboard.reference.put(ref_value);
    scoreboard.dut.put(dut_value);
    ...
    // Call at the the end to check for any leftovers (when more values where pushed to either reference or dut)
    // It will either print a success message or an error (when there is data left-over)
    scoreboard.checkFinished();
    // Can be used to cross-check the number of matches items with the expected number
    if (scoreboard.matchedCount() == ...) ...
    endseq
};
```

## Randomizer

These modules allow you to generate random data.
The main advantages over the `Randomizable` package from the standary libary is:
They either use a seed based on the current time or a user-provided one. With a user-provided seed they will generate reproducable random data sequences (over multiple runs). This is useful to consistenly reproduce bugs which only occur in some cases.

The interface of all modules is as follows:
```
interface Randomizer#(type a);
    method Action init();
    method ActionValue#(a) next();
    method Action destroy();
endinterface
```

All modules expecte a `String` as first parameter. This is used as the name for messages via [Logging](Logging.md).

**Important**: As in the Logging library, this string must *NOT* contain whitespaces.

For simple data types like `Bit` or `UInt`, there are the `mkGenericRandomizer(String)` and `mkConstrainedRandomizer(String, a, a)` modules.
The latter allows to set min and max bounds for the random data generated. Both require the type to be in the `Bounded` typeclass.

For other data, i.e. structs, unions, etc..., you can use the `mkStructRandomizer(String)` module.

Usage Example:

```
Randomizer#(Bit#(32)) rand <- mkGenericRandomizer("MyRand");
Stms s = {
    seq
        rand.init();
        ...
        let r <- rand.next();
        ...
        rand.destroy();
    endseq
};
```

### Seed

By default, the randomizers will use a seed based on the current time, combined with their given name (to produce different data sequences with multiple randomizers). This will thus produce a different data sequence for each run.

It is possible, to instead use a user-provided seed: If `SEED` is set to a value in the `make` call, all randomizers will use this value (still combined with their name).

Example: `make SEED=1234`

At the start of simulation, the used base-seed (before combination with the module names) is printed out. If you want to repeat a specific run, just copy this seed and use it in the make command like above.

**Important**: This reproducibility might break, if you use a single randomizer module in different places.